digraph G {
    label = "identify";

    hasSessionAndProfile [shape = diamond];
    hasSession [shape = diamond];
    hasSafe [shape = diamond];
    hasKey [shape = diamond];
    connectOrCreate [shape = parallelogram];
    isCreatingSafe [shape = diamond];

    start [shape = circle];
    success [shape = circle];

    loadProfile [shape = box];

    start -> hasSessionAndProfile;
    hasSessionAndProfile -> loadProfile [label = "onYes"];
    hasSessionAndProfile -> hasSession [label = "onNo"];
    loadProfile -> hasSafe
    hasSafe -> hasKey [label = "onYes"]
    hasKey -> success [label = "onYes"]
    hasKey -> checkSkipSafeAddress [label = "onNo"]
    hasSafe -> isCreatingSafe [label = "onNo"]
    isCreatingSafe -> connectOrCreate [label = "onNo"]
    isCreatingSafe -> success [label = "onYes"]
    connectOrCreate -> checkSkipSafeAddress [label = "onConnect"]
    connectOrCreate -> generateKey [label = "onCreate"]
    hasSession -> findEntryPoint [label = "onNo"]
    hasSession -> firstName [label = "onYes"]

    subgraph cluster_0 {
        style="dashed";
        color=black;
        fillcolor=lightgray;

        label = "acquireSession";

        subgraph cluster_1 {
            label = "authenticate";

            subgraph cluster_2 {
                label = "getAuthCode";

                loginEmail [shape = parallelogram]
                requestAuthCode [shape = box]
                checkAcceptTos [shape = diamond]
                acceptTos [shape = parallelogram]
                storeAcceptTos [shape = box]
                code [shape = parallelogram]

                loginEmail -> checkAcceptTos
                checkAcceptTos -> requestAuthCode [label = "already accepted"]
                checkAcceptTos -> acceptTos [label = "not yet accepted \nor new version"]
                acceptTos -> storeAcceptTos [label = "don't ask again for\nthe same version"]
                storeAcceptTos -> requestAuthCode  [label = "send email with\ncode to user"]
                requestAuthCode -> code [label = "wait for auth code\nfrom email"]
            }

            findEntryPoint [shape = diamond];
            exchangeCodeForToken [shape = box]

            findEntryPoint -> exchangeCodeForToken [label = "user followed link\nfrom email"]
            findEntryPoint -> loginEmail [label = "no oneTimeCode"]
            code -> exchangeCodeForToken [label = "user entered code\nfrom email"]
        }

        exchangeTokenForSession [shape = box]

        exchangeCodeForToken -> exchangeTokenForSession
    }

    exchangeTokenForSession -> hasSessionAndProfile

    subgraph cluster_3 {
        style="dashed";
        label = "upsertIdentity";

        firstName [shape = parallelogram]
        lastName [shape = parallelogram]
        country [shape = parallelogram]
        dream [shape = parallelogram]
        editAvatar [shape = parallelogram]
        previewAvatar [shape = parallelogram]
        checkPreviewAvatar [shape = diamond]
        checkEditAvatar [shape = diamond]
        checkUploadAvatar [shape = diamond]
        upsertIdentity [shape = box]

        subgraph cluster_4 {
            style="dashed";
            label = "uploadAvatar (uploadFile)";

            authenticateSso [shape = box; style = dashed]
            upload [shape = box;]
            authenticateSso -> upload
        }

        firstName -> lastName [label = "next"]
        lastName -> country [label = "next/skip"]
        country -> dream [label = "next/skip"]
        dream -> checkPreviewAvatar [label = "next"]
        checkPreviewAvatar -> previewAvatar [label = "avatar is already set\n-> preview"];
        checkPreviewAvatar -> checkEditAvatar [label = "avatar not set"];
        previewAvatar -> checkEditAvatar [label = "next"];
        checkEditAvatar -> editAvatar [label = "avatar not set\nor cleared"]
        checkEditAvatar -> upsertIdentity [label = "avatar unchanged"]
        editAvatar -> checkUploadAvatar
        editAvatar -> upsertIdentity [label = "skip"]
        checkUploadAvatar -> authenticateSso [label = "avatar is set"]
        checkUploadAvatar -> upsertIdentity [label = "no avatar"]
        upload -> upsertIdentity
    }

    upsertIdentity -> hasSessionAndProfile

    subgraph cluster_5 {
        style="dashed";
        label = "connectSafe";

        checkSkipSafeAddress [shape = diamond]
        safeAddress [shape = parallelogram]
        checkSafeAddress [shape = box]
        seedPhrase [shape = parallelogram]
        prepareOutput [shape = box]

        checkSkipSafeAddress -> safeAddress [label = "safe address\nnot set"]
        checkSkipSafeAddress -> checkSafeAddress [label = "safe address\nalready set"]
        safeAddress -> checkSafeAddress
        checkSafeAddress -> seedPhrase
        seedPhrase -> prepareOutput
    }

    subgraph cluster_6 {
        style="dashed";
        label = "createSafe";
        generateKey [shape = box]
        backupKeyphrase [shape = parallelogram]
        storeKey [shape = box]
        setFlag [shape = box; label = "Set 'creatingSafe' flag"]

        generateKey -> backupKeyphrase
        backupKeyphrase -> storeKey
        storeKey -> setFlag
    }
    setFlag -> success
    prepareOutput -> success
}



