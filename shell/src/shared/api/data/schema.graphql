# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

interface ICity {
    country: String!
    feature_code: String!
    geonameid: Int!
    latitude: Float!
    longitude: Float!
    name: String!
    population: Int!
}

interface IEventPayload {
    id: Int!
    transaction_id: Int!
}

union EventPayload = CrcHubTransfer | CrcMinting | CrcSignup | CrcTokenTransfer | CrcTrust | EthTransfer | GnosisSafeEthTransfer

type City implements ICity {
    country: String!
    feature_code: String!
    geonameid: Int!
    latitude: Float!
    longitude: Float!
    name: String!
    population: Int!
}

type CityStats implements ICity {
    citizenCount: Int!
    country: String!
    feature_code: String!
    geonameid: Int!
    latitude: Float!
    longitude: Float!
    name: String!
    population: Int!
}

type ClaimInvitationResult {
    claimedInvitation: ClaimedInvitation
    success: Boolean!
}

type ClaimedInvitation {
    claimedAt: String!
    claimedBy: Profile
    claimedByProfileId: Int!
    createdAt: String!
    createdBy: Profile
    createdByProfileId: Int!
}

type ConsumeDepositedChallengeResponse {
    challenge: String
    success: Boolean!
}

type CountryStats {
    citizenCount: Int!
    name: String!
}

type CrcHubTransfer implements IEventPayload {
    flow: String!
    from: String!
    id: Int!
    to: String!
    transaction_id: Int!
    transfers: [CrcTokenTransfer!]!
}

type CrcMinting implements IEventPayload {
    from: String!
    id: Int!
    to: String!
    token: String!
    transaction_id: Int!
    value: String!
}

type CrcSignup implements IEventPayload {
    id: Int!
    token: String!
    transaction_id: Int!
    user: String!
}

type CrcTokenTransfer implements IEventPayload {
    from: String!
    id: Int!
    to: String!
    token: String!
    transaction_id: Int!
    value: String!
}

type CrcTrust implements IEventPayload {
    address: String!
    can_send_to: String!
    id: Int!
    limit: Int!
    transaction_id: Int!
}

type CreateInvitationResult {
    error: String!
    success: Boolean!
}

type CreatedInvitation {
    claimedAt: String
    claimedBy: Profile
    claimedByProfileId: Int
    code: String!
    createdAt: String!
    createdBy: Profile
    createdByProfileId: Int!
}

type DelegateAuthInit {
    appId: String!
    challengeType: String
    delegateAuthCode: String
    errorMessage: String
    success: Boolean!
    validTo: String
}

type DepositChallengeResponse {
    errorMessage: String
    success: Boolean!
}

type EthTransfer implements IEventPayload {
    from: String!
    id: Int!
    to: String!
    transaction_id: Int!
    value: String!
}

type ExchangeTokenResponse {
    errorMessage: String
    success: Boolean!
}

type GnosisSafeEthTransfer implements IEventPayload {
    from: String!
    id: Int!
    initiator: String!
    to: String!
    transaction_id: Int!
    value: String!
}

type Goal {
    totalCitizens: Int!
}

type LockOfferResult {
    lockedUntil: String
    success: Boolean!
}

type LogoutResponse {
    errorMessage: String
    success: Boolean!
}

type Mutation {
    acknowledge(eventPayloadId: Int!): ProfileEvent!
    authenticateAt(appId: String!): DelegateAuthInit!
    claimInvitation(code: String!): ClaimInvitationResult!
    consumeDepositedChallenge(delegateAuthCode: String!): ConsumeDepositedChallengeResponse!
    createInvitation(for: String!): CreateInvitationResult!
    depositChallenge(jwt: String!): DepositChallengeResponse!
    exchangeToken: ExchangeTokenResponse!
    lockOffer(data: LockOfferInput!): LockOfferResult!
    logout: LogoutResponse!
    provePayment(data: PaymentProof!): ProvePaymentResult!
    redeemClaimedInvitation: RedeemClaimedInvitationResult!
    requestUpdateSafe(data: RequestUpdateSafeInput!): RequestUpdateSafeResponse!
    unlistOffer(offerId: Int!): Boolean!
    updateSafe(data: UpdateSafeInput!): UpdateSafeResponse!
    upsertOffer(data: UpsertOfferInput!): Offer!
    upsertProfile(data: UpsertProfileInput!): Profile!
    upsertTag(data: UpsertTagInput!): Tag!
}

type Offer {
    categoryTag: Tag
    categoryTagId: Int!
    city: City
    createdBy: Profile
    createdByProfileId: Int!
    deliveryTermsTag: Tag
    deliveryTermsTagId: Int!
    description: String
    geonameid: Int!
    id: Int!
    maxUnits: Int
    pictureMimeType: String!
    pictureUrl: String!
    pricePerUnit: String!
    publishedAt: String!
    purchasedAt: String
    title: String!
    unitTag: Tag
    unitTagId: Int!
    unlistedAt: String
}

type Profile {
    avatarCid: String
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    circlesSafeOwner: String
    circlesTokenAddress: String
    city: City
    cityGeonameid: Int
    country: String
    dream: String
    firstName: String!
    id: Int!
    lastName: String
    newsletter: Boolean
    offers: [Offer!]
    status: String
}

type ProfileEvent {
    block_number: Int!
    direction: String!
    id: Int!
    payload: EventPayload
    safe_address: String!
    timestamp: String!
    transaction_hash: String!
    transaction_index: Int!
    type: String!
    value: String!
}

type ProvePaymentResult {
    success: Boolean!
}

type Purchase {
    id: Int!
    purchasedAt: String!
    purchasedBy: Profile!
    purchasedByProfileId: Int!
    purchasedFrom: Profile!
    purchasedFromProfileId: Int!
    purchasedItem: Offer!
    purchasedOfferId: Int!
    status: PurchaseStatus!
}

type Query {
    cities(query: QueryCitiesInput!): [City!]!
    claimedInvitation: ClaimedInvitation
    events(safeAddress: String!): [ProfileEvent!]!
    invitationTransaction: ProfileEvent
    myInvitations: [CreatedInvitation!]!
    offers(query: QueryOfferInput!): [Offer!]!
    profiles(query: QueryProfileInput!): [Profile!]!
    safeFundingTransaction: ProfileEvent
    search(query: SearchInput!): [Profile!]!
    sessionInfo: SessionInfo!
    stats: Stats
    tagById(id: Int!): Tag
    tags(query: QueryTagsInput!): [Tag!]!
    version: Version!
    whoami: String
}

type RedeemClaimedInvitationResult {
    redeemRequest: RedeemInvitationRequest
    success: Boolean!
}

type RedeemInvitationRequest {
    id: Int!
}

type RequestUpdateSafeResponse {
    challenge: String
    errorMessage: String
    success: Boolean!
}

type Server {
    version: String!
}

type SessionInfo {
    hasProfile: Boolean
    isLoggedOn: Boolean!
    profileId: Int
}

type Stats {
    cities: [CityStats!]!
    cityRank: Int
    countries: [CountryStats!]!
    currentGoal: Int!
    currentGoalFrom: Int!
    goals: [Goal!]!
    inviteRank: Int!
    nextGoalAt: Int!
    totalCitizens: Int!
}

type Subscription {
    events: [ProfileEvent!]!
}

type Tag {
    id: Int!
    typeId: String!
    value: String
}

type UpdateSafeResponse {
    errorMessage: String
    newSafeAddress: String
    success: Boolean!
}

type Version {
    major: Int!
    minor: Int!
    revision: Int!
}

enum PurchaseStatus {
    INVALID
    ITEM_LOCKED
    PAYMENT_PROVEN
}

input CreateTagInput {
    typeId: String!
    value: String
}

input DepositChallenge {
    jwt: String!
}

input LockOfferInput {
    offerId: Int!
}

input PaymentProof {
    destinations: [String!]!
    forOfferId: Int!
    sources: [String!]!
    tokenOwners: [String!]!
    values: [String!]!
}

input QueryCitiesByGeonameIdInput {
    geonameid: [Int!]!
}

input QueryCitiesByNameInput {
    languageCode: String
    name_like: String!
}

input QueryCitiesInput {
    byId: QueryCitiesByGeonameIdInput
    byName: QueryCitiesByNameInput
}

input QueryOfferInput {
    categoryTagId: Int
    createdByProfileId: Int
    id: Int
    publishedAt_gt: String
    publishedAt_lt: String
}

input QueryProfileInput {
    circlesAddress: [String!]
    country: String
    firstName: String
    id: [Int!]
    lastName: String
}

input QueryPurchaseInput {
    purchasedByProfileId: String!
}

input QueryTagsInput {
    typeId_in: [String!]!
    value_like: String
}

input QueryUniqueProfileInput {
    id: Int!
}

input RequestUpdateSafeInput {
    newSafeAddress: String!
}

input SearchInput {
    searchString: String!
}

input UpdateSafeInput {
    signature: String!
}

input UpsertOfferInput {
    categoryTagId: Int!
    deliveryTermsTagId: Int!
    description: String
    geonameid: Int!
    id: Int
    maxUnits: Int
    pictureMimeType: String
    pictureUrl: String
    pricePerUnit: String!
    title: String!
    unitTagId: Int!
}

input UpsertProfileInput {
    avatarCid: String
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    circlesSafeOwner: String
    circlesTokenAddress: String
    cityGeonameid: Int
    country: String
    dream: String
    emailAddress: String
    firstName: String!
    id: Int
    lastName: String
    newsletter: Boolean
    status: String!
}

input UpsertTagInput {
    id: Int
    typeId: String!
    value: String
}
