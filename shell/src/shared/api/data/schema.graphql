# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

interface IAggregatePayload {
    lastUpdatedAt: String
}

interface ICity {
    country: String!
    feature_code: String!
    geonameid: Int!
    latitude: Float!
    longitude: Float!
    name: String!
    population: Int!
}

interface IEventPayload {
    transaction_hash: String
}

union AggregatePayload = Contacts | CrcBalances | Erc20Balances | Members | Memberships | Offers | Purchases | Sales

union EventPayload = ChatMessage | CrcHubTransfer | CrcMinting | CrcSignup | CrcTokenTransfer | CrcTrust | Erc20Transfer | EthTransfer | GnosisSafeEthTransfer | InvitationCreated | InvitationRedeemed | MemberAdded | MembershipAccepted | MembershipOffer | MembershipRejected | NewUser | OrganisationCreated | Purchased | SafeVerified | SaleEvent | WelcomeMessage

union ProfileOrOrganisation = Organisation | Profile

type AcceptMembershipResult {
    error: String
    success: Boolean!
}

type AddMemberResult {
    error: String
    success: Boolean!
}

type AnnouncePaymentResult {
    invoiceId: Int!
    pickupCode: String!
    transactionHash: String!
}

type AssetBalance {
    token_address: String!
    token_balance: String!
    token_owner_address: String!
    token_owner_profile: Profile
    token_symbol: String
}

type Capability {
    type: CapabilityType
}

type ChatMessage implements IEventPayload {
    from: String!
    from_profile: Profile
    id: Int!
    text: String!
    to: String!
    to_profile: Profile
    transaction_hash: String
}

type City implements ICity {
    country: String!
    feature_code: String!
    geonameid: Int!
    latitude: Float!
    longitude: Float!
    name: String!
    population: Int!
}

type ClaimInvitationResult {
    claimedInvitation: ClaimedInvitation
    success: Boolean!
}

type ClaimedInvitation {
    claimedAt: String!
    claimedBy: Profile
    claimedByProfileId: Int!
    createdAt: String!
    createdBy: Profile
    createdByProfileId: Int!
}

type CommonTrust {
    profile: Profile
    safeAddress1: String!
    safeAddress2: String!
    type: String!
}

type ConsumeDepositedChallengeResponse {
    challenge: String
    success: Boolean!
}

type Contact {
    contactAddress: String!
    contactAddress_Profile: Profile
    lastContactAt: String!
    metadata: [ContactPoint!]!
}

type ContactPoint {
    directions: [ContactDirection!]!
    name: String!
    timestamps: [String!]!
    values: [String!]!
}

type Contacts implements IAggregatePayload {
    contacts: [Contact!]!
    lastUpdatedAt: String!
}

type CrcBalances implements IAggregatePayload {
    balances: [AssetBalance!]!
    lastUpdatedAt: String!
    total: String
}

type CrcHubTransfer implements IEventPayload {
    flow: String!
    from: String!
    from_profile: Profile
    tags: [Tag!]!
    to: String!
    to_profile: Profile
    transaction_hash: String!
    transfers: [CrcTokenTransfer!]!
}

type CrcMinting implements IEventPayload {
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    token: String!
    transaction_hash: String!
    value: String!
}

type CrcSignup implements IEventPayload {
    token: String!
    transaction_hash: String!
    user: String!
    user_profile: Profile
}

type CrcTokenTransfer implements IEventPayload {
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    token: String!
    transaction_hash: String!
    value: String!
}

type CrcTrust implements IEventPayload {
    address: String!
    address_profile: Profile
    can_send_to: String!
    can_send_to_profile: Profile
    limit: Int!
    transaction_hash: String!
}

type CreateInvitationResult {
    createdInviteEoas: [CreatedInvitation!]!
    error: String
    success: Boolean!
}

type CreateOrganisationResult {
    error: String
    organisation: Organisation
    success: Boolean!
}

type CreatedInvitation {
    address: String!
    balance: String!
    claimedAt: String
    claimedBy: Profile
    claimedByProfileId: Int
    code: String!
    createdAt: String!
    createdBy: Profile
    createdByProfileId: Int!
    name: String!
}

type CreatedInviteEoa {
    address: String!
    fee: String!
    for: String!
}

type DelegateAuthInit {
    appId: String!
    challengeType: String
    delegateAuthCode: String
    errorMessage: String
    success: Boolean!
    validTo: String
}

type DepositChallengeResponse {
    errorMessage: String
    success: Boolean!
}

type Erc20Balances implements IAggregatePayload {
    balances: [AssetBalance!]!
    lastUpdatedAt: String!
}

type Erc20Transfer implements IEventPayload {
    from: String!
    from_profile: Profile
    to: String!
    to_profile: Profile
    token: String!
    transaction_hash: String!
    value: String!
}

type EthTransfer implements IEventPayload {
    from: String!
    from_profile: Profile
    tags: [Tag!]!
    to: String!
    to_profile: Profile
    transaction_hash: String!
    value: String!
}

type ExchangeTokenResponse {
    errorMessage: String
    success: Boolean!
}

type GnosisSafeEthTransfer implements IEventPayload {
    from: String!
    from_profile: Profile
    initiator: String!
    tags: [Tag!]!
    to: String!
    to_profile: Profile
    transaction_hash: String!
    value: String!
}

type InvitationCreated implements IEventPayload {
    code: String!
    name: String!
    transaction_hash: String
}

type InvitationRedeemed implements IEventPayload {
    code: String!
    name: String!
    redeemedBy: String
    redeemedBy_profile: Profile
    transaction_hash: String
}

type Invoice {
    buyerAddress: String!
    buyerProfile: Profile
    buyerSignature: Boolean
    buyerSignedDate: String
    cancelReason: String
    cancelledAt: String
    cancelledBy: Profile
    id: Int!
    invoiceNo: String!
    lines: [InvoiceLine!]
    paymentTransaction: ProfileEvent
    paymentTransactionHash: String
    pickupCode: String
    purchase: Purchase
    purchaseId: Int!
    sellerAddress: String!
    sellerProfile: Profile
    sellerSignature: Boolean
    sellerSignedDate: String
}

type InvoiceLine {
    amount: Int!
    id: Int!
    offer: Offer
}

type LogoutResponse {
    errorMessage: String
    success: Boolean!
}

type MemberAdded implements IEventPayload {
    createdBy: String!
    createdBy_profile: Profile
    isAdmin: Boolean!
    member: String!
    member_profile: Profile
    organisation: String!
    organisation_profile: Organisation
    transaction_hash: String
}

type Members implements IAggregatePayload {
    lastUpdatedAt: String!
    members: [ProfileOrOrganisation!]!
}

type Membership {
    acceptedAt: String
    createdAt: String!
    createdBy: Profile
    createdByProfileId: Int!
    isAdmin: Boolean!
    organisation: Organisation!
    rejectedAt: String
    validTo: String
}

type MembershipAccepted implements IEventPayload {
    createdBy: String!
    createdBy_profile: Profile
    member: String!
    member_profile: Profile
    organisation: String!
    organisation_profile: Organisation
    transaction_hash: String
}

type MembershipOffer implements IEventPayload {
    createdBy: String!
    createdBy_profile: Profile
    isAdmin: Boolean!
    organisation: String!
    organisation_profile: Organisation
    transaction_hash: String
}

type MembershipRejected implements IEventPayload {
    member: String!
    member_profile: Profile
    organisation: String!
    organisation_profile: Organisation
    transaction_hash: String
}

type Memberships implements IAggregatePayload {
    lastUpdatedAt: String!
    organisations: [Organisation!]!
}

type Mutation {
    acceptMembership(membershipId: Int!): AcceptMembershipResult
    acknowledge(until: String!): Boolean!
    addMember(groupId: String!, memberAddress: String!): AddMemberResult
    announcePayment(invoiceId: Int!, transactionHash: String!): AnnouncePaymentResult!
    authenticateAt(appId: String!): DelegateAuthInit!
    claimInvitation(code: String!): ClaimInvitationResult!
    completePurchase(invoiceId: Int!, revoke: Boolean): Invoice!
    completeSale(invoiceId: Int!, revoke: Boolean): Invoice!
    consumeDepositedChallenge(delegateAuthCode: String!): ConsumeDepositedChallengeResponse!
    createTestInvitation: CreateInvitationResult!
    depositChallenge(jwt: String!): DepositChallengeResponse!
    exchangeToken: ExchangeTokenResponse!
    importOrganisationsOfAccount: [Organisation!]!
    logout: LogoutResponse!
    purchase(lines: [PurchaseLineInput!]!): [Invoice!]!
    redeemClaimedInvitation: RedeemClaimedInvitationResult!
    rejectMembership(membershipId: Int!): RejectMembershipResult
    removeMember(groupId: String!, memberAddress: String!): RemoveMemberResult
    requestInvitationOffer(for: String!): Offer!
    requestSessionChallenge(address: String!): String!
    requestUpdateSafe(data: RequestUpdateSafeInput!): RequestUpdateSafeResponse!
    revokeSafeVerification(safeAddress: String!): VerifySafeResult!
    sendMessage(content: String!, fromSafeAddress: String, toSafeAddress: String!): SendMessageResult!
    tagTransaction(tag: CreateTagInput!, transactionHash: String!): TagTransactionResult!
    updateSafe(data: UpdateSafeInput!): UpdateSafeResponse!
    upsertOrganisation(organisation: UpsertOrganisationInput!): CreateOrganisationResult!
    upsertProfile(data: UpsertProfileInput!): Profile!
    upsertRegion(organisation: UpsertOrganisationInput!): CreateOrganisationResult!
    upsertTag(data: UpsertTagInput!): Tag!
    verifySafe(safeAddress: String!): VerifySafeResult!
    verifySessionChallenge(challenge: String!, signature: String!): ExchangeTokenResponse
}

type NewUser implements IEventPayload {
    profile: Profile!
    transaction_hash: String
}

type NotificationEvent {
    from: String
    itemId: Int
    transaction_hash: String
    type: String!
}

type Offer {
    createdAt: String!
    createdByAddress: String!
    createdByProfile: Profile
    description: String
    id: Int!
    pictureMimeType: String!
    pictureUrl: String!
    pricePerUnit: String!
    timeCirclesPriceShare: Int!
    title: String!
    version: Int!
}

type Offers implements IAggregatePayload {
    lastUpdatedAt: String!
    offers: [Offer!]!
}

type Organisation {
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    circlesSafeOwner: String
    city: City
    cityGeonameid: Int
    createdAt: String!
    description: String
    displayCurrency: DisplayCurrency
    id: Int!
    members: [ProfileOrOrganisation!]
    name: String!
    offers: [Offer!]
    trustsYou: Int
}

type OrganisationCreated implements IEventPayload {
    organisation: String!
    organisation_profile: Organisation
    transaction_hash: String
}

type Profile {
    avatarCid: String
    avatarMimeType: String
    avatarUrl: String
    balances: ProfileBalances
    circlesAddress: String
    circlesSafeOwner: String
    circlesTokenAddress: String
    city: City
    cityGeonameid: Int
    claimedInvitation: ClaimedInvitation
    contacts: [Contact!]
    country: String
    displayCurrency: DisplayCurrency
    displayName: String
    displayTimeCircles: Boolean
    dream: String
    emailAddress: String
    firstName: String!
    id: Int!
    invitationTransaction: ProfileEvent
    lastName: String
    memberships: [Membership!]
    newsletter: Boolean
    offers: [Offer!]
    origin: ProfileOrigin
    purchases: [Purchase!]
    sales: [Sale!]
    status: String
    successorOfCirclesAddress: String
    type: ProfileType
    verifications: [Verification!]
}

type ProfileAggregate {
    payload: AggregatePayload!
    safe_address: String!
    safe_address_profile: Profile
    type: String!
}

type ProfileBalances {
    crcBalances: CrcBalances
    erc20Balances: Erc20Balances
}

type ProfileEvent {
    block_number: Int
    contact_address: String
    contact_address_profile: Profile
    direction: String!
    payload: EventPayload
    safe_address: String!
    safe_address_profile: Profile
    tags: [Tag!]
    timestamp: String!
    transaction_hash: String
    transaction_index: Int
    type: String!
    value: String
}

type ProofPaymentResult {
    acknowledged: Boolean!
}

type PublicEvent {
    block_number: Int
    contact_address: String
    contact_address_profile: Profile
    payload: EventPayload
    timestamp: String!
    transaction_hash: String
    transaction_index: Int
    type: String!
}

type Purchase {
    createdAt: String!
    createdByAddress: String!
    createdByProfile: Profile
    id: Int!
    invoices: [Invoice!]
    lines: [PurchaseLine!]
    total: String!
}

type PurchaseLine {
    amount: Int!
    id: Int!
    offer: Offer
}

type Purchased implements IEventPayload {
    purchase: Purchase!
    seller: String!
    seller_profile: Profile
    transaction_hash: String
}

type Purchases implements IAggregatePayload {
    lastUpdatedAt: String!
    purchases: [Purchase!]!
}

type Query {
    aggregates(filter: ProfileAggregateFilter, safeAddress: String!, types: [AggregateType!]!): [ProfileAggregate!]!
    cities(query: QueryCitiesInput!): [City!]!
    claimedInvitation: ClaimedInvitation
    commonTrust(safeAddress1: String!, safeAddress2: String!): [CommonTrust!]!
    directPath(amount: String!, from: String!, to: String!): TransitivePath!
    events(filter: ProfileEventFilter, pagination: PaginationArgs!, safeAddress: String!, types: [EventType!]!): [ProfileEvent!]!
    findInvitationCreator(code: String!): Profile
    findSafesByOwner(owner: String!): [SafeInfo!]!
    hubSignupTransaction: ProfileEvent
    invitationTransaction: ProfileEvent
    invoice(invoiceId: Int!): String
    myInvitations: [CreatedInvitation!]!
    myProfile: Profile
    organisations(pagination: PaginationArgs): [Organisation!]!
    organisationsByAddress(addresses: [String!]!): [Organisation!]!
    profilesById(ids: [Int!]!): [Profile!]!
    profilesBySafeAddress(safeAddresses: [String!]!): [Profile!]!
    recentProfiles(pagination: PaginationArgs): [Profile!]!
    regions(pagination: PaginationArgs): [Organisation!]!
    safeInfo(safeAddress: String): SafeInfo
    search(query: SearchInput!): [Profile!]!
    sessionInfo: SessionInfo!
    stats: Stats!
    tagById(id: Int!): Tag
    tags(query: QueryTagsInput!): [Tag!]!
    trustRelations(safeAddress: String!): [TrustRelation!]!
    verifications(filter: VerifiedSafesFilter, pagination: PaginationArgs): [Verification!]!
    version: Version!
}

type RedeemClaimedInvitationResult {
    error: String
    success: Boolean!
    transactionHash: String
}

type RejectMembershipResult {
    error: String
    success: Boolean!
}

type RemoveMemberResult {
    error: String
    success: Boolean!
}

type RequestUpdateSafeResponse {
    challenge: String
    errorMessage: String
    success: Boolean!
}

type SafeAddressByOwnerResult {
    safeAddress: String!
    type: String!
}

type SafeInfo {
    lastUbiAt: String
    randomValue: String
    safeAddress: String!
    safeProfile: Profile
    tokenAddress: String
    type: AccountType!
}

type SafeVerified implements IEventPayload {
    organisation: String!
    organisation_profile: Organisation
    safe_address: String!
    transaction_hash: String
}

type Sale {
    buyerAddress: String!
    buyerProfile: Profile
    createdAt: String!
    id: Int!
    invoices: [Invoice!]
    lines: [SalesLine!]
    paymentTransaction: ProfileEvent
    sellerAddress: String!
    sellerProfile: Profile
    total: String!
}

type SaleEvent implements IEventPayload {
    buyer: String!
    buyer_profile: Profile
    invoice: Invoice
    transaction_hash: String
}

type Sales implements IAggregatePayload {
    lastUpdatedAt: String!
    sales: [Sale!]!
}

type SalesLine {
    amount: Int!
    id: Int!
    offer: Offer!
}

type SendMessageResult {
    error: String
    event: ProfileEvent
    success: Boolean!
}

type Server {
    version: String!
}

type SessionInfo {
    capabilities: [Capability!]!
    hasProfile: Boolean
    isLoggedOn: Boolean!
    lastAcknowledgedAt: String
    profile: Profile
    profileId: Int
}

type Stats {
    profilesCount: Int!
    verificationsCount: Int!
}

type Subscription {
    events: NotificationEvent!
}

type Tag {
    id: Int!
    typeId: String!
    value: String
}

type TagTransactionResult {
    error: String
    success: Boolean!
    tag: Tag
}

type TransitivePath {
    flow: String!
    requestedAmount: String!
    transfers: [TransitiveTransfer!]!
}

type TransitiveTransfer {
    from: String!
    to: String!
    token: String!
    tokenOwner: String!
    value: String!
}

type TrustRelation {
    direction: TrustDirection!
    otherSafeAddress: String!
    otherSafeAddressProfile: Profile
    safeAddress: String!
    safeAddressProfile: Profile
}

type UpdateSafeResponse {
    errorMessage: String
    newSafeAddress: String
    success: Boolean!
}

type Verification {
    createdAt: String!
    revokedAt: String
    revokedProfile: Profile
    verificationRewardTransaction: ProfileEvent
    verificationRewardTransactionHash: String!
    verifiedProfile: Profile
    verifiedSafeAddress: String!
    verifierProfile: Organisation
    verifierSafeAddress: String!
}

type VerifySafeResult {
    success: Boolean!
}

type Version {
    major: Int!
    minor: Int!
    revision: Int!
}

type WelcomeMessage implements IEventPayload {
    invitedBy: String!
    invitedBy_profile: Profile
    transaction_hash: String
}

enum AccountType {
    Organisation
    Person
}

enum AggregateType {
    Contacts
    CrcBalances
    Erc20Balances
    Members
    Memberships
    Offers
    Purchases
    Sales
}

enum CapabilityType {
    Invite
    Verify
}

enum ContactDirection {
    In
    Out
}

enum Direction {
    in
    out
}

enum DisplayCurrency {
    CRC
    EURS
    TIME_CRC
}

enum EventType {
    ChatMessage
    CrcHubTransfer
    CrcMinting
    CrcSignup
    CrcTokenTransfer
    CrcTrust
    Erc20Transfer
    EthTransfer
    GnosisSafeEthTransfer
    InvitationCreated
    InvitationRedeemed
    MemberAdded
    MembershipAccepted
    MembershipOffer
    MembershipRejected
    NewUser
    OrganisationCreated
    Purchased
    SafeVerified
    SaleEvent
    WelcomeMessage
}

enum ProfileOrigin {
    CirclesGarden
    CirclesLand
    Unknown
}

enum ProfileType {
    ORGANISATION
    PERSON
    REGION
}

enum SortOrder {
    ASC
    DESC
}

enum TrustDirection {
    IN
    MUTUAL
    OUT
}

input ChatMessageEventFilter {
    id: Int!
}

input ContactAggregateFilter {
    addresses: [String!]!
}

input CrcBalanceAggregateFilter {
    tokenAddresses: [String!]!
}

input CreateTagInput {
    typeId: String!
    value: String
}

input DepositChallenge {
    jwt: String!
}

input OffersAggregateFilter {
    createdByAddresses: [String!]
    offerIds: [Int!]
}

input PaginationArgs {
    continueAt: String
    continueAtId: Int
    limit: Int!
    order: SortOrder!
}

input ProfileAggregateFilter {
    contacts: ContactAggregateFilter
    crcBalance: CrcBalanceAggregateFilter
    offers: OffersAggregateFilter
    purchases: PurchasesAggregateFilter
    sales: SalesAggregateFilter
}

input ProfileEventFilter {
    chatMessage: ChatMessageEventFilter
    direction: Direction
    from: String
    purchased: PurchasedEventFilter
    to: String
    transactionHash: String
    with: String
}

input PurchaseLineInput {
    amount: Int!
    offerId: Int!
}

input PurchasedEventFilter {
    id: Int!
}

input PurchasesAggregateFilter {
    createdByAddresses: [String!]
    pickupCode: String
    purchaseIds: [Int!]
}

input QueryCitiesByGeonameIdInput {
    geonameid: [Int!]!
}

input QueryCitiesByNameInput {
    languageCode: String
    name_like: String!
}

input QueryCitiesInput {
    byId: QueryCitiesByGeonameIdInput
    byName: QueryCitiesByNameInput
}

input QueryProfileInput {
    circlesAddress: [String!]
    country: String
    firstName: String
    id: [Int!]
    lastName: String
}

input QueryTagsInput {
    typeId_in: [String!]!
    value_like: String
}

input QueryUniqueProfileInput {
    id: Int!
}

input RequestUpdateSafeInput {
    newSafeAddress: String!
}

input SalesAggregateFilter {
    createdByAddresses: [String!]
    pickupCode: String
    salesIds: [Int!]
}

input SearchInput {
    searchString: String!
}

input UpdateSafeInput {
    signature: String!
}

input UpsertOrganisationInput {
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    cityGeonameid: Int
    description: String
    displayCurrency: DisplayCurrency
    id: Int
    name: String!
}

input UpsertProfileInput {
    avatarCid: String
    avatarMimeType: String
    avatarUrl: String
    circlesAddress: String
    circlesSafeOwner: String
    circlesTokenAddress: String
    cityGeonameid: Int
    country: String
    displayCurrency: DisplayCurrency
    displayTimeCircles: Boolean
    dream: String
    emailAddress: String
    firstName: String!
    id: Int
    lastName: String
    newsletter: Boolean
    status: String!
    successorOfCirclesAddress: String
}

input UpsertTagInput {
    id: Int
    typeId: String!
    value: String
}

input VerifiedSafesFilter {
    addresses: [String!]
}
